공부 정리


프로세스 - 운영체제에서는 실행 중인 하나의 애프리케이션을 프로세스라 부른다. 프로그램이란 스태틱한 하나의 명세이다.
이 명세가 컴퓨터 메모리를 할당받아 실행 되고 있다면 그것이 프로세스이다. OOP를 예를 들면 클래스에 해당하는게 프로그램이고 클래스로 부터 인스턴스화 되서 동적으로 돌아가고 있는 객체에 해당하는 것이 프로세스이다.  즉 운영체게 위에서 살아 움직이고 있는 프로그램을 프로세스라 한다. 프로세스 끼리는 서로 독립적이다. 운영체제로 부터 각자 독립적으로 메모리영역을 할당 받기 떄문에 서로 정보의 공유가 안되고 하나의 프로세스 안에서 오류가 나도 다른 프로세스에 영향을 전혀 미치지 않는다. 


쓰레드 - 하나의 프로세스안에 여러개의 작업흐름이 있을 수 있는데 각각 하나의 흐름을 쓰레드라 한다. 여러개의 쓰레드가 동시에 작동 할 수 도 있다. 프로세스에는 최소 하나이상의 쓰레드가 존재한다. 쓰레드들은 하나의 프로세스(메모리)에 속하기 때문에 정보를 공유 할 수 있다. 또한 멀티 쓰레드들 중 하나의 쓰레드가 고장나면 다른 쓰레드에도 영향을 미칠 수 있다. 프로세스가 꺼질 수 도 있다 . 

thread 우선순위 - CPU코어의 개수보다 멀티 쓰레드의 개수가 많을 경우 쓰레드 우선순위로 CPU의 점유율이 결정 된다.
CPU코어의 개수보다 멀티 쓰레드의 개수가 적을 경우에는 쓰레드 우선순위는 의미 없다.

임계영역 - 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역이라고 한다. 자바는 임계영역을 지정하기 위해 동기화 메서드와 동기화 블록을 제공 한다. 만약 동기화 메소드와 동기화 블록이 여러개 있을 경우, 스레드가 이들 중 하나를 실행할 때 다른 스레드는 해당 메소드는 물론이고 다른 동기화 메소드 및 블록도 실행 할 수 없다. 하지만 일반 메소드는 실행이 가능하다.

스레드 상태 - 스레드는 실행대기와 실행을 왔다갔다 거리면서 처리가 된다. 


유니코드 문자열입니다.




문(statement)하고 식(expression)의 차이점이 무엇이냐?
AOT컴파일 언어란 무엇인가?
카고 - 러스트의 빌드 시스템이자 패키지 매니저이다. 
      1) 코드 빌드
      2) 의존성 다운로드
      3) 의존성 라이브러리 다운로드 후 빌드
      빌드 명령어는 cargo build
      카고는 소스파일이 src폴더에 존재 할 것을 전제 한다.
      카고에서 라이브러리를 만들때에는 lib.rs라는 명명 규칙을 따라야 한다. 물론 원한다면 변경 할 수 있다.
      카고로 빌드 할때에는 src 폴더에 main.rs가 존재 해야 한다.
      빌드 후 실행은 cargo run을 해도 된다. 
      실제 실행 파일 위치는 ./target/debug/폴터 아래에 존재 한다.
      카고는 자동으로 어느 프로젝트 파일이 수정되었는지 확인하고, 수정된 코드만 다시 빌드한다. 
    - 배포용으로 빌드를 할 경우에는 cargo build --release라고 한다.
      이러면 최적화 옵션을 빌드를 한다. 컴파일이 굉장히 오래 걸린다. 
    - 카고 프로젝트를 만들려면
      cargo new hello_world --bin을 한다.
      (--bin을 하는 이유는 만들려고 하는 것이 라이브러리가 아니라 실행 파일이기 때문이다.)
    - 카고는 git전역 설정도 해준다. hello_world 디렉터리를 만들 때 git 레포지터리를
      시작 한다. 

 러스트는 변수는 기본적으로 이뮤터블하다 그런데 뮤터블한 변수를 선언 할 필요도 있으므로
 그때는 mut라는 걸 변수 선언 앞에 써준다.
 ex) let mut foo;
     let foo = 5; //immutable.
     let mut bar = 5; //mutable.

 String::new()에서 ::를 사용하는 이유는 이것이 어떤 특정한 타입과'연결된 함수'이기 때문이다.
 new()함수가 String의 인스턴스 하나하나에 연결되는 것이 아니라, String 그 자체에 연결되어 있다는 것을 
 의미 한다. 일부 언어에서 이것을 '정적 메서드'하고 부른다.  

 io::stdin().read_line(&mut guess)
 에서 io::stdin()은 소스의 맨 윗줄에 use std::io로 임포트 한거에 연결된 것을 호출 하는 것이다.
 만약 use std::io를 선언 하지 않았었다면 이렇게 써야 한다.
 std::io::stdin()..... 마치 자바의 패키지 구조 같다. 

 io::stdin()을 통해 터미널의 표준 입력에 대한 핸들을 반환한다.

 .read_line()는 메서드인데 이것 연결된함수가 아니라 해당 타입의 각 인스턴스들에서만 사용 가능하다.

 (&mut guess)를 했는데 이는 guess변수를 참조 하겠다는 것이고 앞에 mut가 붙은 이유는
 참조는 기본적으로 불변이기 때문이다. 

난수를 발생시키는 기능이 러스트의 표준 라이브러리에 포함되어 있지 않기 떄문에
우리는 크레이트라는 걸 선언해서 사용 할 것이다. 간단히 말하면 외부 라이브러리 이다.
자바로 치면 외부 jar같은 개념이다. 
자바의 메이븐에서 외부 라이브러리를 의존할려면 dependencies에 세팅을 했듯이
러스트도 cargo를 통해서 dependencies를 선언 한다.

20161110t3



해킹 회사/hack




-- 궁금사항 --
1. 병행(동시성)과 병렬의 비교
  - 동시성은 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질을 말하고, 병렬성은 멀티 작업을 위해
    멀티 코어에서 개별 스레드를 동시에 실행하는 성질을 말한다. 
  - 내생각은 동시성은 코어 하나에서 멀티 쓰레드로 되나 코어가 여러개에서 멀티쓰레드로 되나 동시에 여러개의 스레드를 돌린다면
    동시성은 성립하는 것 같다. 다만 병렬성은 실제 물리적으로 여러개의 코어가 각각 스레드를 나눠서 실행해줄때를 말하는 것 같다.
  ? 서로다른 코어에서 시간차를 두고 2개의 task가 실행된다면 이걸 병렬처리라 할 수 있는 것인가?
    병행은 성립 하는가?

args4j 소스 분석 할 것 (MIT라이센스라서 마음대로 수정해도 됨 GITHUB에 올릴 것)
내방식대로 수정해서 올릴 것
이름은 nargs4j(new-args4j)



기도서비스 스팩

1. 회원 가입을 한다.
   - SNS 연동 가입을 할 것인지 아님 id/passwd로 할 것 인지....
   - 회원 가입으로 한다. (단 정보를 잃어버리느느 것을 대비해 가입시에 email을 입력 한다.)
2. 로그인을 한다.    
3. 메뉴가 존재한다.
   - 기도하기
   - 예전 기도 찾기
   - 옵션
     - 기도 검색 화면 암호 걸기 및 변경 (나만 보기 위한 이중 장치)
4. RESTful로 개발하여 view를 여러가지로 해도 서비스가 될 수 있도록 개발 한다. 
5. GITHUB을 새로 만든다.





더 커피클럽
http://coffeeclub.me/


기술 스팩 
- springBoot
- AngularJS
- JQuery
- BootStrap
- MySQL
- Spring-DATA-JPA
- DDD
- Spring-Security
- thymeleaf



CEP논문에 나오는 서비스 개발(기술 위주의 개발)

사용기술
1. spring boot
2. esper
3. 스케줄링 
4. angularJS
5. EASY UI


중계 서비스 분석


스마츠 rule코딩 관련 drools로 컨버팅 하는 프로그램 개발

mongoOWL 분석 후 재 개발 할 것 


DDD연습 할 것
1. 비디오 숍 관리
2. 헬스장 관리
3. 도서관 솔루션
4. 대학교 종합정보 시스템(시설 쪽)


oAuth2.0 서버 구축해 볼 것


[2016-11-14]
스프링 로디드로 간편하게 개발하기

JRebel같은게 기본으로 스프링에 존재 한다. (hot reloading기능)
springloaded라는 것인데 maven으로 추가 하면 된다.

<궁금점>
스프링 부트에서 객체 생성할때의 스코프를 어떻게 설정하는지?
singleton 이나 prototype이나 ..

JavaConfig 관련 공부 할 것 



EASYUI - 공부 할 것
강요천 - 애노테이션 개발하는 것 공부 할 것



[2016-11-17]
<궁금점>
java에서 문자열은 3byte인 거 같은데 이걸 2바이트인 char에 charAt로 집어 넣을 수 있다. 
왜 이런 것인가?

[2016-11-29]
-value object pattern
-프로그래밍에서 엔트로피가 높아진다는 것은?
-이터너티의 DDD 볼 것
-DDD Start 6장과 1장 시작 할 것
-JPA 시작 할 것 
-valueObject 는 항상 equals를 구현해야 하는 이유는?

- equals와 hashCode 설명
  equals는 동등성을 비교 한다.
  hashCode는 동일성을 비교 한다. 

  hashCode관련 읽어 볼 것
  http://anster.tistory.com/160

-삼각측량이란 무엇인가?
-flyweight factory?
-시그니처에 대해 정확히 공부 할 것
-정적 팩토리 메서드란?

-테스트케이스가 빨간 막대로 된사항에서 다른 테스트 케이스를 추가 하지 않는다.


[알고리즘 강좌]
- 시간 복잡도 : 어떤 문제 입력의 크기에 따라서 내가 작성한 코드가 시간이 얼마나 걸릴지를 예측하는 방법이다.
  정확하게 예측을 하지는 않는다. 가장 안좋은 경우에 시간이 얼마나 걸릴지를 표현하는 방법이다. 
- 시간복잡도에 가장큰 입력밤위를 넣고 계산해서 1억정도나오면 1초걸린다고 보면 됨
  o(n) 일경우 가장큰 값을을 n 에 넣었을때 1억이 나오냐? 
  o(n)일때는 n이 즉 가장 큰 입력 값이 1억이면 결과로 1억이 나온다.
  o(nlgN)은 가장 큰입력값이 5백만일경우에 1억정도가 나온다.

-시간 복잡도의 의미
  o(1): 단순 계산(a+b 와 같은 연산, 배열에 접근하는 연산)
  o(lgN): N개를 절반으로 계속해서 나눔 또는 트리같은걸 사용 했을때
  o(N): 1중 for문
  o(NlgN): 
  o(n^2): 2중 for 문
  o(n^3): 3중 for 문
  o(2^n): 크기가 n인 집합의 부분 집합
   데이터가 n개가 있을때
  1,2,3,4,5,...,n
  1번째 데이터가 있을경우 혹은 없을경우 2가지
  2번째 데이터가 있을경우 혹은 없을경우 2가지
  3번째 데이터가 있을경우 혹은 없을경우 2가지....
  이렇게 n번이라면 2^n이다.

  o(n!): 크기가 n인 순열
   데이터가 n개가 있을때
   1,2,3,...,n 이 있을때
   n개를 모두 다해야 하는데 순서가 중요할때
   즉 1,2,3.... 으로 할거냐
   1,3,2,...로 할거냐 할때 n!이 나올수 있음

-시간복잡도의 중요성이란 구현을 하기전에 어떻게 구현을할지 생각하는
시점에 시간복잡도를 따져 봐야 한다.
즉 문제에서 주어진 최대 입력값을 내가 만들려고 하는 프로그램의
시간복잡도에 대입해봐서 제한시간안에 끝날것인지 대략 계산해 봐야 한다.

-스택을 이용하면 o(n^2)이였던게 왜 o(1)로 되는지?








[논문 볼 것]
http://www.riss.kr/search/detail/DetailView.do?p_mat_type=1a0202e37d52c72d&control_no=ce560496b573da25ffe0bdc3ef48d419#redirect

http://www.riss.kr/search/detail/DetailView.do?p_mat_type=1a0202e37d52c72d&control_no=54d04dc513b28cc8c85d2949c297615a#redirect

[라이브러리 프레임웍 플랫폼 차이점]
http://blog.gaerae.com/2016/11/what-is-library-and-framework-and-architecture-and-platform.html?utm_content=buffer91577&utm_medium=social&utm_source=facebook.com&utm_campaign=buffer

[TDDBE리뷰]
https://ethdemor.wordpress.com/2010/09/27/test-driven-development-1%EB%B6%80-%EB%A6%AC%EB%B7%B0/

[TDD 삼각측량]
http://kin3d.tistory.com/entry/051203-1120-TDD-%EA%B0%80%EC%A7%9C%EA%B5%AC%ED%98%84%EC%82%BC%EA%B0%81%EC%B8%A1%EB%9F%89%EB%AA%85%EB%B0%B1%ED%95%9C%EA%B5%AC%ED%98%84


객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성등 시스템의 복잡성을 제어 할 수 있는 다양한 장치를 제공한다.

JPA를 사용해서 find를 두번해서 객체를 가져오면 두 객체의 동일 비교는 참이 나온다. 단 같은 트랜젝션 내에서만 그렇다. 
JPA는 동일한 트랜젝션에서 조회한 객체는 항상 동일성이 보장 된다. 

JPA의 모든 조작은 트랜젝션 블럭 안에서 코딩되어 져야 한다. 스프링을 쓴다면 @Transactional안에서 코딩 되어져야 한다.

PK는 미래에도 변하지 않는 값을 선정해야 한다.
안되는 것들의 예로 전화번호: 전화번호를 키로 썻는데 나중에 전화번호가 변경되면 
난감해진다. 주민번호: 변경이 안될거 같으나 변경될 소지가 있다 정통부 법에 의해 주민번호를 다 없애라!
그러면 모든 pk및 fk를 다고쳐 줘야 한다. 컬럼(자연키)들 중에서 pk로 사용할 수 있는 값들이 존재할거
같으나 사실 거의 없다. 그래서 ORM에서는 PK는 비즈니스와 전혀 무관한 시퀀스나 오토인크리 같은걸로 쓰라고 한다. 
Long+대체키를 사용하는걸 권장한다. 

객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다. -조용호-
객체지향에서 가장 중요한것이 협력 관계를 만드는 것이다. 
테이블은 조인등을 통해 연관관계 테이블을 찾지만 객체는 참조를 통해 연관객체를 찾는다. 테이블과 객체의 가장큰 차이이다. 

@ManyToOne은 테이블관점에서 이다. 
@JoinColumn(name="TEAM_ID")여기서 TEAM_ID는 테이블의 컬럼 명이다.
즉 테이블에 관련된걸보고 세팅을 해준다. 

Team team = new Team();
team.setName("TeamA");
em.persist(tema); //기본적으로 em에 퍼시스트를 해놓고 나서 사용해야 한다. 스프링이란 비슷하다 컨테이너가 관리
할 수 있도록 해놓고 나서 한다. 

객체가 양방향 관계이면 그냥 양쪽다 값(team에는 member을 member에는 team을)을 세팅해 줘야 한다.

@ManyToOne 나 @OneToOne은 기본값이 즉시로딩이다. 사용할때 lazy로딩으로 변경하고 사용하는걸 권장한다.

update시 기본적으로 모든 컬럼을 업데이트 한다.
만약 동적으로 수정되는 컬럼만 업데이트 할려고 하면
엔티티에 다음과 같은 어노테이션을 붙여 준다.
@org.hibernate.anotations.DynamicUpdate

@DynamicInsert라는 것도 있는데 이는 데이터를 저장할때 데이터가 존재하는(null이 아닌) 필드만으로 Insert sql을
동적으로 생성한다. 

영속성 컨텍스트를 flush하는 방법 3가지
1. em.flush()를 직접 호출한다.
2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
3. JPQL쿼리 실행 시 플러시가 자동 호출된다.

-EntityManager에 플러시 모드를 직접 지정하려면 javax.persistence.FlushModeType를 사용 하면 된다.
FlushModeType.AUTO 커밋이나 쿼리를 실행할 때 플러시(기본값)
FlushModeType.COMMIT 커밋할 떄만 플러시 

<질문>
p.108 왜 JPQL은 flush()를 하는가?
JPQL은 그명령어가 실행 되는 시점에 실제 SQL로 번역되서 db에서 조회를 하는데
만약 데이터가 db에 안 들어가 있으면 의도한데로 안될거기 때문에 JPQL시 flush를 하고나서 
처리 한다. 

<질문>
p.117 영속성 컨텍스트에서 엔티티를 비영속으로 변경했다 그러면 스냅샷이고 뭐고 다 날라간다.
이상태에서 새로운 em에 좀전의 엔티티를 머지하면 db가 업데이트가 되는데 어떻게 더티체크를 하는것인가?

<궁금점>
데이터베이스에서 catalog기능이 무엇인지 알아 볼 것
데이터베이스에서 schema기능이 무엇인지 알아 볼 것
테이블에서 유니크 제약조건을 건다는 것이 무슨 의미인가? (기본키에는 참여하지 않는 특정열이 중복을 허용하지 
않도록 할 떄 : https://technet.microsoft.com/ko-kr/library/ms191166(v=sql.105).aspx )

<궁금점>
데이터베이스에서 ID를 자동을 생성하는 방법이 있는데
시퀀스라는게 무엇인지.. 키생성 테이블이라는게 무엇인지 알아 볼 것
오라클은 시퀀스를 제공하고 mysql은 제공을 안한다는데 이게 무슨 소리인지?
Table전략은 키 생성용 테이블을 하나 만들어두고 마치 시쿼스처럼 사용하는 방법이라고 되어 있는데 이게 무슨 소리인지?

<테스트>
1. 유니크 컬럼을 지정하고 실제로 동일 컬럼을 삽입 해보기
2. 

p.164
- 연관관계의 주인 : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.

<궁금점>
db에서 join관련해서 공부 해 둘것 inner join 이라든지 하는거....




2013/09/01 ~ 2016/10/31

1. 몽고owl 기능개선 참여
2. 몽고bird 기능개선 참여
3. leophant 개발 참여 (storm 부분)
3. etri 힐링플랫폼 1차, 2차 3차 참여
4. 한화 s&c 코엑스 프로젝트 참여
5. 유안타 증권 프로젝트 참여
6. 몽고DB 컨설팅 참여
7. 몽고DB 샤드 매니저 개발
8. khiron DB 모니터링 개발


[HazelCast]
인메모리 데이터 그리드란?
NoSQL의 일종인가?
JCO 인피니스팬 동영상 찾아 볼 것
페일 오버 관련 (고가용성 문제)
리플리케이션이 되는지.
어떤 용도로 주로 사용하는지..
주키퍼 대용으로 써도 되는지..
모니터링 같은건 할 수 있는지...
스케일 아웃을 하려면 클러스터를 내려야 하는지..

각서버가 active모드로 동작한다는데 이게 무슨 의미인지?
용량의 한계와 신뢰성은 어떻게 극복 할 것인가? (장애가 발생하면 데이터는 손실 되는가?)

AS는 IMDG가 제공하는 클라이언트 라이브러리를 가지고 IMDG에 접근을 한다.

분산은 어떤 원리로 되는가 ? 단순한 modulo인가 아님 consistency hash 방식인가?

hazelcast는 Map을 분산시킬 수 있다. 

LRU 와 LFU 알고리즘 ?

DistributedMap & DistributedMultiMap ?

분산 코디네이션은 어떻게 하는지? (분산된 List의 count나 조회를 하면 여러 노드에 걸쳐 퍼져있는
리스트의 데이터를 종합을 해야하는데 이걸 하는 주체는 어느 노드인가?)

MultiMap란 무엇인가?

-publish순서를 보장하는 Topic읽기가 가능하다고 하는데. 분산 Message Queue 시스템으로 이용할 수 있다고 한다.
여기서 메세지 큐란? publish는 뭔지?

-분산락이 지원된다.

-DistributedMap 이나 DistributedQueue등에대해 트랜젝션을 걸 수 있다. 

-hazelcast 는 수십기가에 해당하는 heap를 잡기 때문에 fullGC 시간이 오래걸린다. 
 그래서 off-heap메모리(Direct Buffer)를 사용한다. 

 객관적으로 성능이 뛰어나다는 건 어떻게 알수 있나?

 힙을 1기가정도로 잡고 나머지는 offheap메모리로 잡아서 fullgc때 시간 잡아먹는것을 없앤다.

싱크를 어떻게 맞추는지 db와 
 
 @wildnez

 캐싱이란 데이터를 메모리안에 보관하는 것이다. 왜냐? 빠르게 처리하기 위해 

eviction-policy


[강의]
자동복원력 기능이 있음 jvm하나가 하나의 노드이다. 
늘어날경우에 자동으로 데이터가 분산 저장 된다.
다른 imdg등에 비해서 성능이 좋음
애플스토어 1000개의 앱서버 (40 헤즐케스트 노드사용함)
각서버에 256g 메모리
high-density memory store 기능적용

hazelcast jet (spark or flink 와 비교할 수 있다.)


rahul@hazelcast.com

강의 했던 github 주소
https://github.com/wildnez/public-training/tree/master/essentials/labs/lab5/src/main







-storm



-kafka

-mongoDB


[querydsl 관련]
http://www.querydsl.com/static/querydsl/3.6.3/reference/ko-KR/html_single/

[오라클 시퀀스 관련]
http://www.gurubee.net/lecture/1037

[java관련 전문가 그룹]
http://gnujava.com/

[git관련]
https://gs.saro.me/#!m=elec&jn=854

[java 익명 객체 관련]
http://rain483.blog.me/220583776237

[slipp.net - 스프링 스터디한거 ]
https://slipp.net/wiki/pages/viewpage.action?pageId=22282248

[queals 분석 삼실청년]
http://egloos.zum.com/iilii/v/3999066

[java equals와 hash코드 관련]
http://skylit.tistory.com/35
http://anster.tistory.com/160

[백명석 클린코더스 강좌 자료]
https://raw.githubusercontent.com/msbaek/clean-coders-2013/master/2.Functions.png

[axboot 관련]
http://www.oss.kr/oss_repository28/661342

[아샬의 TDD 관련]
https://github.com/ahastudio/til/blob/master/blog/2016/12-03-tdd-faq.md

[시력을 향상 시키는 방법]
http://media.daum.net/life/health/wellness/newsview?newsId=20161206094937244

[clojure 잘하는 중국 사람]
https://github.com/clojurians-org

[2016-12-12]
1. 기업은행 적금 일반 계좌로 돌려 놓기
2. 기업은행 IRP계좌 개설 -->ok
3. 카디날에 IRP계과 사진찍어 보내기 
4. 텐서플로우 공부 (김박사 강의 및 조대협 강의로)
5. 몽고DB 강좌 보기
6. 알고리즘 책 1장 끝내기
7. 일빵빵 2장까지 듣기 및 연습
8. 기도앱 개발 스펙 정하기
http://onoffmix.com/event/86240
http://onoffmix.com/event/86239

[백건우 기사]
http://v.media.daum.net/v/20161212030217393


[2016-12-13]
1. jpa 5장 및 연습
2. 기도앱 스팩 작성 및 개발 시작
3. 머신러닝 공부하기
4. 수학적으로 사고하기 책 읽기
5. 로마서 공부하기
6. 몽고db 강좌 보기
7. 카디날 에트리 프로젝트 공부 하기

[2016-12-15]
http://tvpot.daum.net/v/v098buA0vi80005sulIvujs
http://www.slideshare.net/daumdna/devon-2012-b4-orm
1. 텐서플로우 관련 공부
2. 미적분 공부
3. 일빵빵 4강까지
4. 몽고db 다 볼 것
   -주종면
   -sk 교육센터꺼
5. effective java 공부 할것
6. 부트스트랩 공부 할 것
7. crudproject - 스프링 부트로 로그인 만들 것
8. 백기선의 스프링부트 관련 동영상 1강 볼 것


[jupyter-notebook 관련 설명]
http://www.slideshare.net/dahlmoon/jupyter-notebok-20160815

[머신러닝 공부]
구글에서 공개한 강좌
- https://www.youtube.com/watch?v=cKxRvEZd3Mw&t=183s 

아이리스 플라워 데이터셋
https://en.wikipedia.org/wiki/Iris_flower_data_set

지도학습을 사용하려면 표준절차 몇단계를 따라야 한다.
첫째 훈련 데이터를 모으기 이다. 
여기서 훈련데이터란 우리가 해결할려고 하는 문제들이다.

머신러닝이란 명시적으로 프로그래밍을 하지 않고도 컴퓨터가 학습할 수 있는 능력을 갖게 하는 것
경험이 많을 수록 퍼포먼스가 좋아지게 하는 것이 머신러닝의 핵심이다. 

선형회귀를 머신러닝에서 사용을 하는데 이게 우선은 직선에서 부터 시작을해서 점진적으로 
피팅을 해나간다 그러면 곡선이 될수도 있고 다른 모양이 될수도 있고 그렇다. 이렇게 되가는
과정이 머신러닝이다. 

지도학습이란 알고리즘에게 정확한 답을 알고 있는 데이터세트를 준다는 데에서 유래

선형회귀란 연속적인 값을 예측하는 문제이다.

지도학습 - 분류문제 


[김성훈 교수 강의]
1. 선형 회귀 부분 
   h(x) = WX + b 라는 템플릿을 만들고
   여러개의 가설을 찾는다. 그리고 나서 각 가설이 어떤게 좋은지를 판단한다.
   판단 방법은 가설이 나타내는 데이터 점 과 실제 데이터 점의 거리의 차이를 비교해서 정한다.
   거리를 계산해야 하는데 이걸 선형회귀에서 cost(Loss) funtion이라고 한다. 
   거리를 계산 해야 하는데 이때 H(x) - y (즉 가설식으로 나온 값들에서 실제 값들을 빼준다)
   제곱을 해줘서 음수로 나오는 걸 방지 한다. ( H(x)- y)^2 <- 이렇게 하면 패널티가 생기는데
   거리가 멀수록 제곱한 값이 굉장히 커져 비용함수의 결과값이 커질 수 있다. 즉 각요소들의 거리가 
   가장 짧을 수록 유리 하다. 
   (h(x)-y)^2를 cost function이라 한다.

   만약 값이 3개가 있다면

   ( (h(x1)-y1)^2 + (h(x2)-y2)^2 + (h(x3)-y3)^2 ) / 3 이 된다.

   가설식 h(x) = Wx + b인데 이걸 cost function에 대입하면 결국 cost function은 W,b의 함수로 간주할 수 있다
   cost(W,b) 이렇게...  그렇다면 결국 w,b에 의해서 가장 좋은 가설을 선택 할 수 있게 된다. (즉 가설의 값이 가장
   작게 나오는 w,b를 찾으면 되는 것이다. 즉 선형회귀 학습의 목표는 가설식을 가장 작게 만드는 w,b를 찾는 것이다.
   이걸 최소화 하는 많은 알고리즘이 존재 한다. )











